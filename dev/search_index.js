var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiQuantityGPs\nShareDefaultModule = true","category":"page"},{"location":"#MultiQuantityGPs","page":"Home","title":"MultiQuantityGPs","text":"","category":"section"},{"location":"#Quick-Intro","page":"Home","title":"Quick Intro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Following is a quick example of the main functionality of this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, the package is loaded and 2D region bounds are chosen.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MultiQuantityGPs: MQGP, quantityCovMat, quantityCorMat, MQSample\n\nbounds = (\n    lower = [0.0, 0.0],\n    upper = [1.0, 1.0]\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A collection of locations and quantity indices for 2 quantities is randomly generated. The 2D function to model uses a sine with an offset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Random: seed! # hide\nseed!(0) # hide\n\n# latin hypercube create first quantity sample positions\nn = 4\npos1 = [[i,j] .+ rand(2)/n for i in 0:1/n:1-1/n for j in 0:1/n:1-1/n]\n\n# randomly create first quantity values\nf = (x1,x2) -> sin(7*x1) + 2*x2\nf1 = (x1,x2) -> f(x1,x2) + 1/2*randn()\nqnt1_samples = [MQSample((x=(p,1), y=f1(p...))) for p in pos1]\n\n# latin hypercube create second quantity sample positions\nn = 5\npos2 = [[i,j] .+ rand(2)/n for i in 0:1/n:1-1/n for j in 0:1/n:1-1/n]\n\n# randomly create second quantity sample values\nf2 = (x1,x2) -> -10*f(x1,x2) + 3*randn()\nqnt2_samples = [MQSample((x=(p,2), y=f2(p...))) for p in pos2]\n\n# full sample collection\nsamples = [qnt1_samples; qnt2_samples]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MQGP is created from the samples and bounds. It's hyperparameter values are learned.","category":"page"},{"location":"","page":"Home","title":"Home","text":"mqgp = MQGP(samples; bounds,\n            noise_value=zeros(2), noise_learn=true,\n            means_use=true, means_learn=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Values from the MQGP can be viewed, such as the noise hyperparameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mqgp.θ.σn","category":"page"},{"location":"","page":"Home","title":"Home","text":"Predicted value and uncertainty for a single sample:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mqgp(([0.39, 0.28], 2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Predicted value and uncertainty for multiple samples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mqgp([([0.4, 0.5], 1), ([0.39, 0.28], 2)])","category":"page"},{"location":"","page":"Home","title":"Home","text":"The quantity covariance matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"quantityCovMat(mqgp)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or the quantity correlation matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"quantityCorMat(mqgp)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following plots show the two quantities, the samples of those quantities, and the predicted values and uncertainties produced by the MQGP across the region.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Plots\n\naxs = range.(bounds..., (100, 100))\npoints = collect.(Iterators.product(axs...))\n\nplots = map(1:2) do quantity\n    pred_map, err_map = mqgp(tuple.(points, quantity))\n\n    xp = first.(getfield.(filter(s -> s.x[2] == quantity, samples), :x))\n    x1 = getindex.(xp, 1)\n    x2 = getindex.(xp, 2)\n\n    true_map = (f1,f2)[quantity].(axs[1],axs[2]')\n    map_datas = true_map, pred_map, err_map\n    titles = \"ground truth\", \"expected value\", \"standard deviation\"\n\n    map(map_datas, titles) do map_data, title\n        heatmap(axs..., map_data')\n        scatter!(x1, x2;\n            title=\"$title $quantity\",\n            legend=nothing,\n            color=:green,\n            markersize=4)\n    end\nend\n\nplot(\n    stack(plots; dims=1)...,\n    layout=grid(3,2),\n    size=(950,1000)\n)\nsavefig(\"predictions_and_uncertainties.png\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Further-Info","page":"Home","title":"Further Info","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See below for further details on each type and method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MultiQuantityGPs]","category":"page"},{"location":"#MultiQuantityGPs.MultiQuantityGPs","page":"Home","title":"MultiQuantityGPs.MultiQuantityGPs","text":"This module contains everything to do with what is inferred about values in the environment. In practical terms: means, variances, and correlations. This is all built on Gaussian Processes.\n\nMain public types and functions:\n\nMQGP\nMQSample\nSQSample\nfullCov\ngetLoc\ngetObs\ngetQuant\nmeanDerivAndVar\nquantityCorMat\nquantityCovMat\n\n\n\n\n\n","category":"module"},{"location":"#MultiQuantityGPs.Bounds","page":"Home","title":"MultiQuantityGPs.Bounds","text":"struct NamedTuple{(:lower, :upper), Tuple{Vector{Float64}, Vector{Float64}}}\n\nThe bounds of the region. Consists of the lower and upper bounds, each a list of floating-point values.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.LinearModel","page":"Home","title":"MultiQuantityGPs.LinearModel","text":"A multivariate linear model of y dependent on x with parameters a and b of the form\n\nY = a + b^T X\n\nX and Y are matrices containing the points as columns.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.LinearModel-NTuple{4, Any}","page":"Home","title":"MultiQuantityGPs.LinearModel","text":"Returns a linear model of set of variables Y conditioned on set X. Requires full mean vector and covariance matrix of the joint normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Location","page":"Home","title":"MultiQuantityGPs.Location","text":"mutable struct Array{Float64, 1} <: DenseVector{Float64}\n\nLocation of sample\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.MQGP","page":"Home","title":"MultiQuantityGPs.MQGP","text":"struct MQGP{T}\n\nBelief model struct and function for multiple quantities with 2D inputs.\n\nDesigned on top of a Multi-Quantity Gaussian Process, but can still be used with a single quantity.\n\nIts interface: X -> μ, σ (SampleInputs -> means, standard deviations)\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.MQGP-Tuple{AbstractArray{<:@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}}}","page":"Home","title":"MultiQuantityGPs.MQGP","text":"MQGP(\n    samples::AbstractArray{<:@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}};\n    bounds,\n    N,\n    kernel,\n    means_use,\n    means_learn,\n    noise_value,\n    noise_learn,\n    use_cond_pdf\n) -> MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}\n\n\nCreates and returns a MQGP with hyperparameters trained and conditioned on the samples given. Lower and upper bounds are used to initialize one of the hyperparameters.\n\nA noise standard deviation can optionally be passed in either as a single scalar value for all samples or a vector of values, one for each sample.\n\nExamples\n\n# create a MQGP\nbeliefModel = MQGP([prior_samples; samples]; bounds)\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.MQGP-Tuple{Tuple{Vector{Float64}, Int64}}","page":"Home","title":"MultiQuantityGPs.MQGP","text":"Inputs:\n\nX: a single sample input or an array of multiple\nfull_cov: (optional) if this is true, returns the full covariance matrix in place of the vector of standard deviations\n\nOutputs:\n\nμ, σ: a pair of expected value(s) and uncertainty(s) for the given point(s)\n\nExamples\n\nX = [([.1, .2], 1),\n     ([.2, .1], 2)]\nμ, σ = beliefModel(X) # result: [μ1, μ2], [σ1, σ2]\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.MQSample","page":"Home","title":"MultiQuantityGPs.MQSample","text":"struct NamedTuple{(:x, :y), Tuple{Tuple{Vector{Float64}, Int64}, Float64}}\n\nType of sample measurement with noise, the measurement mean and standard deviation\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.MQSampleInput","page":"Home","title":"MultiQuantityGPs.MQSampleInput","text":"struct Tuple{Vector{Float64}, Int64}\n\nMulti-quantity sample input, the combination of: (Location, quantity index)\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.NoisySampleOutput","page":"Home","title":"MultiQuantityGPs.NoisySampleOutput","text":"struct Tuple{Float64, Float64}\n\nType of sample measurement with noise, the measurement mean and standard deviation\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.SQSample","page":"Home","title":"MultiQuantityGPs.SQSample","text":"struct NamedTuple{(:x, :y), Tuple{Vector{Float64}, Float64}}\n\nType of sample measurement with noise, the measurement mean and standard deviation\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.SampleOutput","page":"Home","title":"MultiQuantityGPs.SampleOutput","text":"primitive type Float64 <: AbstractFloat 64\n\nType of noise-free sample measurement\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.createLossFunc-NTuple{5, Any}","page":"Home","title":"MultiQuantityGPs.createLossFunc","text":"createLossFunc(\n    X,\n    Y_vals,\n    Y_errs,\n    kernel,\n    use_cond_pdf\n) -> MultiQuantityGPs.var\"#12#13\"\n\n\nThis function creates the loss function for training the GP. The negative log marginal likelihood is used.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.fullCov-Tuple{MQGP, AbstractArray{Tuple{Vector{Float64}, Int64}}}","page":"Home","title":"MultiQuantityGPs.fullCov","text":"fullCov(\n    bm::MQGP,\n    X::AbstractArray{Tuple{Vector{Float64}, Int64}}\n) -> Any\n\n\nReturns the full covariance matrix for the belief model.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.getLoc-Tuple{@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}}","page":"Home","title":"MultiQuantityGPs.getLoc","text":"getLoc(\n    s::@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}\n) -> Vector{Float64}\n\n\nGet the location for the sample.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.getLoc-Tuple{@NamedTuple{x::Vector{Float64}, y::Float64}}","page":"Home","title":"MultiQuantityGPs.getLoc","text":"getLoc(\n    s::@NamedTuple{x::Vector{Float64}, y::Float64}\n) -> Vector{Float64}\n\n\nGet the location for the sample.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.getObs-Tuple{@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}}","page":"Home","title":"MultiQuantityGPs.getObs","text":"getObs(\n    s::@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}\n) -> Float64\n\n\nGet the observation for the sample.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.getObs-Tuple{@NamedTuple{x::Vector{Float64}, y::Float64}}","page":"Home","title":"MultiQuantityGPs.getObs","text":"getObs(\n    s::@NamedTuple{x::Vector{Float64}, y::Float64}\n) -> Float64\n\n\nGet the observation for the sample.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.getQuant-Tuple{@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}}","page":"Home","title":"MultiQuantityGPs.getQuant","text":"getQuant(\n    s::@NamedTuple{x::Tuple{Vector{Float64}, Int64}, y::Float64}\n) -> Int64\n\n\nGet the quantity for the sample.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.latentCovMat-Tuple{MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}}","page":"Home","title":"MultiQuantityGPs.latentCovMat","text":"latentCovMat(\n    bm::MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}\n) -> Any\n\n\nGives the covariance matrix between all latent functions from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.meanDerivAndVar-Tuple{MQGP, Tuple{Vector{Float64}, Int64}}","page":"Home","title":"MultiQuantityGPs.meanDerivAndVar","text":"meanDerivAndVar(\n    bm::MQGP,\n    x::Tuple{Vector{Float64}, Int64}\n) -> Tuple{Any, Any}\n\n\nReturns the normed gradient of the mean of the belief model and its variance.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.optimizeLoss-Tuple{Any, Any}","page":"Home","title":"MultiQuantityGPs.optimizeLoss","text":"optimizeLoss(lossFunc, θ0; solver, iterations) -> Any\n\n\nRoutine to optimize the lossFunc and return the optimal parameters θ.\n\nCan pass in a different solver. NelderMead is picked as default for better speed with about the same performance as LFBGS.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.quantityCorMat-Tuple{MQGP}","page":"Home","title":"MultiQuantityGPs.quantityCorMat","text":"quantityCorMat(beliefModel::MQGP)\n\nGives the correlation matrix between all quantities from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.quantityCovMat-Tuple{MQGP}","page":"Home","title":"MultiQuantityGPs.quantityCovMat","text":"quantityCovMat(bm::MQGP) -> Any\n\n\nGives the covariance matrix between all quantities from the hyperparameters. The model of the quantities is the latent functions plus their measurement noise.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Modules = [Kernels]","category":"page"},{"location":"#MultiQuantityGPs.Kernels.SLFMMOKernel","page":"Home","title":"MultiQuantityGPs.Kernels.SLFMMOKernel","text":"SLFMMOKernel(g::AbstractVector{<:Kernel}, A::AbstractMatrix)\n\nKernel associated with the semiparametric latent factor model.\n\nDefinition\n\nFor inputs x x and output dimensions p p, the kernel is defined as\n\nkbig((x p) (x p)big) = sum^Q_q=1 A_p qg_q(x x)A_p q\n\nwhere g_1 ldots g_Q are Q kernels, one for each latent process, and A is a matrix of weights for the kernels of size m times Q.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.Kernels.customKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.customKernel","text":"customKernel(\n    θ\n) -> MultiQuantityGPs.Kernels.CustomMOKernel{_A, <:AbstractMatrix{T}} where {_A, T}\n\n\nCreates a custom kernel function for the GP similar to the slfmKernel but with matrices of length-scales and amplitudes.\n\nThis one does not work and is likely not theoretically valid.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.fullyConnectedCovMat-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.fullyConnectedCovMat","text":"fullyConnectedCovMat(a) -> Any\n\n\nCreates an output covariance matrix from an array of parameters by filling a lower triangular matrix.\n\nInputs:\n\na: parameter vector, must hold (N+1)*N/2 parameters, where N = number of outputs\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.fullyConnectedCovNum-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.fullyConnectedCovNum","text":"fullyConnectedCovNum(num_outputs) -> Any\n\n\nGives the number of hyperparameters for to fill the fullyConnectedCovMat.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.mtoKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.mtoKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a MTGP and gives them initial values. This is for a specialized quantity covariance matrix with separation.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.multiKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.multiKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a MTGP and gives them initial values.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.slfmKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.slfmKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a SLFM and gives them initial values.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.manyToOneCovMat-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.manyToOneCovMat","text":"manyToOneCovMat(a) -> Any\n\n\nCreates an output covariance matrix from an array of parameters by filling the first column and diagonal of a lower triangular matrix.\n\nInputs:\n\na: parameter vector, must hold 2N-1 parameters, where N = number of outputs\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.manyToOneCovNum-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.manyToOneCovNum","text":"manyToOneCovNum(num_outputs) -> Any\n\n\nGives the number of hyperparameters for to fill the manyToOneCovMat.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.mtoKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.mtoKernel","text":"mtoKernel(θ) -> KernelFunctions.IntrinsicCoregionMOKernel\n\n\nCreates a kernel function for the GP, which is similar to a multiKernel but instead uses a many-to-one quantity covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.multiKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.multiKernel","text":"multiKernel(θ) -> KernelFunctions.IntrinsicCoregionMOKernel\n\n\nA multi-task GP kernel, a variety of multi-output GP kernel based on the Intrinsic Coregionalization Model with a Squared Exponential base kernel and an output matrix formed from a lower triangular matrix.\n\nThis function creates the kernel function used within the GP.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.multiMean-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.multiMean","text":"multiMean(\n    θ\n) -> AbstractGPs.CustomMean{Tf} where Tf<:MultiQuantityGPs.Kernels.var\"#13#14\"\n\n\nCreates a quantity-specific constant mean function from the GP hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.singleKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.singleKernel","text":"singleKernel(θ) -> Any\n\n\nA simple squared exponential kernel for the GP with parameters θ.\n\nThis function creates the kernel function used within the GP.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.slfmKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.slfmKernel","text":"slfmKernel(\n    θ\n) -> MultiQuantityGPs.Kernels.SLFMMOKernel{_A, <:AbstractMatrix{T}} where {_A, T}\n\n\nCreates a semi-parametric latent factor model (SLFM) kernel function for the GP.\n\n\n\n\n\n","category":"method"}]
}
