var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiQuantityGPs","category":"page"},{"location":"#MultiQuantityGPs","page":"Home","title":"MultiQuantityGPs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MultiQuantityGPs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MultiQuantityGPs]","category":"page"},{"location":"#MultiQuantityGPs.MultiQuantityGPs","page":"Home","title":"MultiQuantityGPs.MultiQuantityGPs","text":"This module contains everything to do with what is inferred about values in the environment. In practical terms: means, variances, and correlations. This is all built on Gaussian Processes.\n\nMain public types and functions:\n\nMQGP\nfullCov\nmeanDerivAndVar\nquantityCorMat\nquantityCovMat\n\n\n\n\n\n","category":"module"},{"location":"#MultiQuantityGPs.Bounds","page":"Home","title":"MultiQuantityGPs.Bounds","text":"struct NamedTuple{(:lower, :upper), Tuple{Vector{Float64}, Vector{Float64}}}\n\nThe bounds of the region. Consists of the lower and upper bounds, each a list of floating-point values.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.LinearModel","page":"Home","title":"MultiQuantityGPs.LinearModel","text":"A multivariate linear model of y dependent on x with parameters a and b of the form\n\nY = a + b^T X\n\nX and Y are matrices containing the points as columns.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.LinearModel-NTuple{4, Any}","page":"Home","title":"MultiQuantityGPs.LinearModel","text":"Returns a linear model of set of variables Y conditioned on set X. Requires full mean vector and covariance matrix of the joint normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Location","page":"Home","title":"MultiQuantityGPs.Location","text":"mutable struct Array{Float64, 1} <: DenseVector{Float64}\n\nLocation of sample\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.MQGP","page":"Home","title":"MultiQuantityGPs.MQGP","text":"struct MQGP{T}\n\nBelief model struct and function for multiple quantities with 2D inputs.\n\nDesigned on top of a Multi-Quantity Gaussian Process, but can still be used with a single quantity.\n\nIts interface: X -> μ, σ (SampleInputs -> means, standard deviations)\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.MQGP-Tuple{Any, @NamedTuple{lower::Vector{Float64}, upper::Vector{Float64}}}","page":"Home","title":"MultiQuantityGPs.MQGP","text":"MQGP(\n    samples,\n    bounds::@NamedTuple{lower::Vector{Float64}, upper::Vector{Float64}};\n    N,\n    kernel,\n    means,\n    noise,\n    use_cond_pdf\n) -> MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}\n\n\nCreates and returns a MQGP with hyperparameters trained and conditioned on the samples given. Lower and upper bounds are used to initialize one of the hyperparameters.\n\nA noise standard deviation can optionally be passed in either as a single scalar value for all samples or a vector of values, one for each sample.\n\nExamples\n\n# create a MQGP\nbeliefModel = MQGP([M.prior_samples; samples], bounds)\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.MQGP-Tuple{Tuple{Vector{Float64}, Int64}}","page":"Home","title":"MultiQuantityGPs.MQGP","text":"Inputs:\n\nX: a single sample input or an array of multiple\nfull_cov: (optional) if this is true, returns the full covariance matrix in place of the vector of standard deviations\n\nOutputs:\n\nμ, σ: a pair of expected value(s) and uncertainty(s) for the given point(s)\n\nExamples\n\nX = [([.1, .2], 1),\n     ([.2, .1], 2)]\nμ, σ = beliefModel(X) # result: [μ1, μ2], [σ1, σ2]\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.SampleInput","page":"Home","title":"MultiQuantityGPs.SampleInput","text":"struct Tuple{Vector{Float64}, Int64}\n\nSample input, the combination of: (Location, sensor index)\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.createLossFunc-NTuple{5, Any}","page":"Home","title":"MultiQuantityGPs.createLossFunc","text":"createLossFunc(\n    X,\n    Y_vals,\n    Y_errs,\n    kernel,\n    use_cond_pdf\n) -> MultiQuantityGPs.var\"#15#16\"\n\n\nThis function creates the loss function for training the GP. The negative log marginal likelihood is used.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.fullCov-Tuple{MQGP, AbstractArray{Tuple{Vector{Float64}, Int64}}}","page":"Home","title":"MultiQuantityGPs.fullCov","text":"fullCov(\n    bm::MQGP,\n    X::AbstractArray{Tuple{Vector{Float64}, Int64}}\n) -> Any\n\n\nReturns the full covariance matrix for the belief model.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.latentCovMat-Tuple{MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}}","page":"Home","title":"MultiQuantityGPs.latentCovMat","text":"latentCovMat(\n    bm::MQGP{typeof(MultiQuantityGPs.Kernels.multiKernel)}\n) -> Any\n\n\nGives the covariance matrix between all latent functions from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.meanDerivAndVar-Tuple{MQGP, Tuple{Vector{Float64}, Int64}}","page":"Home","title":"MultiQuantityGPs.meanDerivAndVar","text":"meanDerivAndVar(\n    bm::MQGP,\n    x::Tuple{Vector{Float64}, Int64}\n) -> Tuple{Any, Any}\n\n\nReturns the normed gradient of the mean of the belief model and its variance.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.optimizeLoss-Tuple{Any, Any}","page":"Home","title":"MultiQuantityGPs.optimizeLoss","text":"optimizeLoss(lossFunc, θ0; solver, iterations) -> Any\n\n\nRoutine to optimize the lossFunc and return the optimal parameters θ.\n\nCan pass in a different solver. NelderMead is picked as default for better speed with about the same performance as LFBGS.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.quantityCorMat-Tuple{MQGP}","page":"Home","title":"MultiQuantityGPs.quantityCorMat","text":"quantityCorMat(beliefModel::MQGP)\n\nGives the correlation matrix between all quantities from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.quantityCovMat-Tuple{MQGP}","page":"Home","title":"MultiQuantityGPs.quantityCovMat","text":"quantityCovMat(bm::MQGP) -> Any\n\n\nGives the covariance matrix between all quantities from the hyperparameters. The model of the quantities is the latent functions plus their measurement noise.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Modules = [Kernels]","category":"page"},{"location":"#MultiQuantityGPs.Kernels.SLFMMOKernel","page":"Home","title":"MultiQuantityGPs.Kernels.SLFMMOKernel","text":"SLFMMOKernel(g::AbstractVector{<:Kernel}, A::AbstractMatrix)\n\nKernel associated with the semiparametric latent factor model.\n\nDefinition\n\nFor inputs x x and output dimensions p p, the kernel is defined as\n\nkbig((x p) (x p)big) = sum^Q_q=1 A_p qg_q(x x)A_p q\n\nwhere g_1 ldots g_Q are Q kernels, one for each latent process, and A is a matrix of weights for the kernels of size m times Q.\n\n\n\n\n\n","category":"type"},{"location":"#MultiQuantityGPs.Kernels.customKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.customKernel","text":"customKernel(\n    θ\n) -> MultiQuantityGPs.Kernels.CustomMOKernel{_A, <:AbstractMatrix{T}} where {_A, T}\n\n\nCreates a custom kernel function for the GP similar to the slfmKernel but with matrices of length-scales and amplitudes.\n\nThis one does not work and is likely not theoretically valid.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.fullyConnectedCovMat-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.fullyConnectedCovMat","text":"fullyConnectedCovMat(a) -> Any\n\n\nCreates an output covariance matrix from an array of parameters by filling a lower triangular matrix.\n\nInputs:\n\na: parameter vector, must hold (N+1)*N/2 parameters, where N = number of outputs\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.fullyConnectedCovNum-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.fullyConnectedCovNum","text":"fullyConnectedCovNum(num_outputs) -> Any\n\n\nGives the number of hyperparameters for to fill the fullyConnectedCovMat.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.mtoKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.mtoKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a MTGP and gives them initial values. This is for a specialized quantity covariance matrix with separation.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.multiKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.multiKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a MTGP and gives them initial values.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.initHyperparams-Tuple{Any, Any, Any, Any, typeof(MultiQuantityGPs.Kernels.slfmKernel)}","page":"Home","title":"MultiQuantityGPs.Kernels.initHyperparams","text":"initHyperparams(\n    X,\n    Y_vals,\n    bounds,\n    N,\n    ::typeof(MultiQuantityGPs.Kernels.slfmKernel);\n    kwargs...\n) -> NamedTuple{(:σ, :ℓ), <:Tuple{Any, Any}}\n\n\nCreates the structure of hyperparameters for a SLFM and gives them initial values.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.manyToOneCovMat-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.manyToOneCovMat","text":"manyToOneCovMat(a) -> Any\n\n\nCreates an output covariance matrix from an array of parameters by filling the first column and diagonal of a lower triangular matrix.\n\nInputs:\n\na: parameter vector, must hold 2N-1 parameters, where N = number of outputs\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.manyToOneCovNum-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.manyToOneCovNum","text":"manyToOneCovNum(num_outputs) -> Any\n\n\nGives the number of hyperparameters for to fill the manyToOneCovMat.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.mtoKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.mtoKernel","text":"mtoKernel(θ) -> KernelFunctions.IntrinsicCoregionMOKernel\n\n\nCreates a kernel function for the GP, which is similar to a multiKernel but instead uses a many-to-one quantity covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.multiKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.multiKernel","text":"multiKernel(θ) -> KernelFunctions.IntrinsicCoregionMOKernel\n\n\nA multi-task GP kernel, a variety of multi-output GP kernel based on the Intrinsic Coregionalization Model with a Squared Exponential base kernel and an output matrix formed from a lower triangular matrix.\n\nThis function creates the kernel function used within the GP.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.multiMean-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.multiMean","text":"multiMean(\n    θ\n) -> AbstractGPs.CustomMean{Tf} where Tf<:MultiQuantityGPs.Kernels.var\"#13#14\"\n\n\nCreates a quantity-specific constant mean function from the GP hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.singleKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.singleKernel","text":"singleKernel(θ) -> Any\n\n\nA simple squared exponential kernel for the GP with parameters θ.\n\nThis function creates the kernel function used within the GP.\n\n\n\n\n\n","category":"method"},{"location":"#MultiQuantityGPs.Kernels.slfmKernel-Tuple{Any}","page":"Home","title":"MultiQuantityGPs.Kernels.slfmKernel","text":"slfmKernel(\n    θ\n) -> MultiQuantityGPs.Kernels.SLFMMOKernel{_A, <:AbstractMatrix{T}} where {_A, T}\n\n\nCreates a semi-parametric latent factor model (SLFM) kernel function for the GP.\n\n\n\n\n\n","category":"method"}]
}
